| **Phase** | **Component** | **AI Prompt** |
| :--- | :--- | :--- |
| **System Architecture & Setup** | Architecture Diagram | "Act as an AWS solutions architect specializing in cost optimization. Generate a detailed Mermaid.js architecture diagram for a serverless document translation system optimized for minimum AWS costs. Include: 1) Angular frontend deployed on S3+CloudFront, 2) Spring Boot backend on AWS Lambda (not EC2) using Java 17, 3) Python/Flask text processing microservices on Lambda with Graviton2 ARM processors, 4) Hugging Face 'facebook/mbart-large-50-many-to-many-mmt' model with request batching to reduce API costs, 5) S3 Intelligent-Tiering for storage cost optimization, 6) DynamoDB with on-demand capacity and auto-scaling for job tracking, 7) SQS Standard queues with message compression for async processing, 8) Stripe Elements for PCI-compliant payments with cost-effective pricing tier, 9) AWS KMS with customer-managed keys for encryption, 10) CloudWatch with custom metrics and dashboards optimized for cost monitoring. Show all data flows with encryption states and include cost estimation notes for each component based on 10,000 monthly translations." |
| **Project Setup** | Spring Boot Initialization | "You are an expert Java Spring Boot developer focused on AWS cost optimization. Create a Spring Boot 3.2 application optimized for AWS Lambda deployment (not traditional EC2). Include these specific dependencies in pom.xml: spring-boot-starter-web, spring-boot-starter-security, aws-java-sdk-s3, aws-java-sdk-dynamodb, aws-java-sdk-sqs, spring-boot-starter-json, and structured logging with Log4j2 JSON layout. Implement serverless-ready configuration with environment-based profiles, async processing enabled with @Async, and cold start optimization techniques. Include GDPR-compliant audit logging that minimizes CloudWatch log costs by filtering unnecessary verbose logs. Add detailed cost tracking metrics per translation job to monitor AWS service expenses." |
| **Frontend Setup** | Angular Application | "As a senior Angular developer specializing in cost-effective cloud deployment, generate an Angular 17 application optimized for static hosting on AWS S3+CloudFront. Use Angular Material with tree-shaking to minimize bundle size. Implement a file upload component with drag-drop, chunked uploads to handle large files efficiently, and language selection supporting all 50+ MBART languages with intelligent lazy-loading. Create a payment integration UI using Stripe Elements with optimized payment flow to reduce failed transaction costs. Implement responsive design with CSS Grid/Flexbox and structured logging that samples debug logs (not all) to minimize logging costs. Include comprehensive TypeScript interfaces for translation job status with detailed phases: UPLOADED, VALIDATING, PROCESSING, TRANSLATING, QUALITY_CHECK, COMPLETED, FAILED." |
| **Core Translation Flow** | File Upload API | "As a Spring Boot expert focused on cost optimization, create a @RestController multipart file upload endpoint with these specific features: 1) Validate file type (PDF/DOCX) and strict 10MB size limit to prevent cost overruns, 2) Implement client-side encryption using AWS KMS before S3 storage to reduce data transfer costs, 3) Use async processing with SQS to minimize Lambda execution time, 4) Return efficient job ID using UUID v7, 5) Implement GDPR audit logging that samples rather than logs every action to reduce costs, 6) Add comprehensive content moderation using AWS Rekognition cost-effective API tier, 7) Include cost tracking per upload with estimated processing cost calculation." |
| **Document Processing** | Python Microservice | "Act as a Python AWS Lambda specialist focused on cost optimization. Create a Flask endpoint for AWS Lambda that: 1) Extracts text from S3 documents using python-docx and pdfplumber with memory optimization to reduce Lambda memory costs, 2) Implements comprehensive error handling with circuit breakers to prevent infinite retry costs, 3) Returns structured JSON responses with efficient data structures to minimize bandwidth costs, 4) Includes virus scanning using ClamAV integration with scan caching to reduce duplicate scan costs, 5) Uses Python 3.11 runtime on Graviton2 ARM processor for best price-performance, 6) Implements structured JSON logging with sampling to control CloudWatch costs, 7) Adds cost metadata to each operation for detailed expense tracking." |
| **Translation Integration** | Hugging Face API Call | "As a Java developer specializing in cost-effective API integration, write a Spring WebClient service to call Hugging Face's MBART model with these cost optimization features: 1) Implement request batching to reduce API call costs, 2) Use efficient JSON serialization with Jackson to minimize data transfer costs, 3) Implement smart retry logic with exponential backoff and circuit breakers to prevent cost overruns during API outages, 4) Include language validation against supported languages with client-side caching to reduce validation costs, 5) Add content moderation for translated output using AWS Rekognition cost-effective tier, 6) Use structured logging with cost metadata for each translation operation, 7) Implement response caching with Redis to reduce duplicate translation costs." |
| **Async Processing** | SQS Implementation | "You are an AWS messaging expert focused on cost optimization. Implement SQS integration in Spring Boot with these features: 1) Use SQS Standard queues (not FIFO) for lower cost, 2) Implement message compression to reduce data transfer costs, 3) Create efficient service that sends compressed messages to SQS with minimal metadata, 4) Implement listener that processes messages in batches to reduce Lambda invocation costs, 5) Configure dead-letter queue with intelligent retry policies to prevent infinite processing costs, 6) Include detailed monitoring metrics for queue length and processing time with cost alerts, 7) Ensure encryption in transit and at rest using AWS KMS cost-effective key policies, 8) Implement cost tracking per message processed." |
| **Payment Integration** | Stripe Implementation | "As a full-stack developer specializing in payment cost optimization, integrate Stripe into Spring Boot with: 1) PaymentIntent endpoint that calculates cost based on precise word count and language pair complexity with caching to reduce calculation overhead, 2) Implement efficient free tier limits (500 chars/day) using Redis with optimized data structures to minimize memory costs, 3) Add GDPR-compliant data handling with automatic data purging to reduce storage costs, 4) Implement webhook handling with idempotency keys to prevent duplicate payment processing costs, 5) Include automated refunds with cost-effective Stripe fee recovery, 6) Add detailed payment cost tracking with reconciliation features." |
| **Security & Compliance** | End-to-End Encryption | "Act as a security engineer focused on cost-effective security. Implement end-to-end encryption using AWS KMS with: 1) Customer-managed keys with automatic rotation for security, 2) S3 bucket policies that enforce encryption and use S3 Intelligent-Tiering for cost optimization, 3) Pre-signed URLs with 15-minute expiration to reduce security risks, 4) GDPR right-to-be-forgotten endpoint that efficiently purges user data from S3, DynamoDB, and logs with batch operations to reduce costs, 5) Audit logging with intelligent sampling to balance security and cost, 6) Cost monitoring for KMS operations with alerts for unusual activity." |
| **Testing** | Comprehensive Test Suite | "As a QA automation engineer focused on cost-effective testing, create a comprehensive test suite with: 1) JUnit tests with Mockito that minimize external dependencies to reduce test execution costs, 2) Integration tests with Testcontainers that use reusable containers to minimize setup costs, 3) Performance tests with JMeter that simulate realistic user loads with efficient resource usage, 4) Security tests that focus on high-risk areas to minimize testing overhead, 5) GDPR compliance tests with automated data cleanup to reduce storage costs, 6) Structured test reporting with cost metrics for each test cycle." |
| **Deployment** | AWS CDK Infrastructure | "You are an AWS CDK expert specializing in cost-optimized infrastructure. Write TypeScript CDK code that deploys: 1) S3 buckets with Intelligent-Tiering and lifecycle policies for cost savings, 2) DynamoDB with on-demand capacity and auto-scaling based on actual usage patterns, 3) SQS queues with compression and cost-effective standard queues, 4) Lambda functions with Graviton2 ARM processors, optimized memory settings, and provisioned concurrency for cost-performance balance, 5) API Gateway with caching and efficient usage plans, 6) CloudFront with compression and optimal caching policies, 7) Least-privilege IAM roles with permission boundaries, 8) Canary deployment with traffic shifting to minimize deployment risks, 9) Cost allocation tags for all resources with budgeting alerts." |
| **Monitoring** | CloudWatch Dashboard | "As a DevOps engineer focused on cost-effective monitoring, create CloudWatch dashboards that track: 1) Translation job metrics with cost per job calculations, 2) System health with focus on error rates and cost-impacting metrics, 3) Cost tracking with per-service breakdowns and anomaly detection, 4) Security events with efficient filtering to reduce alert fatigue, 5) Automated alerts for cost overruns, performance degradation, and security issues, 6) Structured JSON logging with sampling and log retention policies to control costs." |
| **Optimization** | Cost Optimization | "Act as a cloud cost optimization specialist. Implement: 1) Redis caching with intelligent TTL policies (7 days for frequent requests, 1 hour for rare ones), 2) Lambda functions migrated to ARM/Graviton2 processors with memory optimization, 3) Auto-scaling for Lambda based on SQS queue length with cost-aware scaling policies, 4) Cost allocation tags and budgeting alerts with 80% utilization warnings, 5) Job prioritization for paid users with efficient queue management, 6) S3 Lifecycle policies to automatically archive old files to Glacier for storage savings, 7) Regular cost review and optimization recommendations based on usage patterns." |


